# 封装一个wxrequest
+ 首先判断是否登录，是否存在token,如果不存在会去获取token
+ 获取token之后，接着调用当前接口
+ 如果接口调用成功，返回resolve
+ 如果接口调用失败，并且返回的code码代表登录失效，把token置空，销毁失效的token,再重新走一遍登录和调用当前接口
+ 如果还是调用失败，去走统一的错误处理
+ 如果接口调用成功，返回resolve
+ 注意1： 接口中包含黑名单
+ 注意2： 接口中的url中是否有家属id，如果有家属id的话，统一会走黑名单，接口调用的相关信息是属于患者数据



+ 对wx.request进行promise封装
  + 发起请求之前，查看接口是否在黑名单之中
  + 过滤黑名单的接口，只可以处理读操作，不可以处理写操作
  + 统一添加的header
  + 统一添加url
  + 统一处理timeout
  + 统一的错误处理（可以选择个性化的错误页面，也可以用统一的错误弹窗）


+ 获取token接口
  + 首先判断是否有token，如果没有去调登录接口
  + 注意：要处理多个接口都失效，同时调用登录接口的情况，维护一个登录队列和当前登录状态
  + 只有登录状态为false时，去登录，并把登录状态设为true，登录队列的数据移除
  + 登录成功,返回成功的resolve
  + 登录失败,返回失败的reject


+ 登录接口
  + 先微信登录，拿到微信登录接口的返回数据
  + 去调我们项目的登录接口，保存有用的信息， token，userId(患者Id),memberId(家属Id)
  + 处理登录接口返回数据
  + 登录成功,返回成功的resolve
  + 登录失败，返回失败的reject

+ 统一处理错误
  + 分为几类错误，统一处理
  + 如果想自定义处理错误，返回一个reject，在调用接口页面单独处理

# 策略模式
+ 判断用户是否注册过，根据stage判断，如果为0，代表未注册，如果不为0，代表注册，统一跳转到首页
+ 未注册用户
+ 场景值： 扫码进入， 分享进入， 从小程序进入，其他方式进入
  + 一个处理场景值的函数，把场景值对应的入口，写一个json，并return对应的入口那个函数
  + 调用这个函数，传入场景值以及对应的options，getStrategy(scene)(option)
  

+ 扫码进入的渠道： jd入口，jd安联入口，保险入口，itellisure国药入口


+ 定义：该模式定义了一系列算法，并将每个算法封装起来，使它们相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理

+ 优点：如果使用多重条件转移语句实现，不但使条件语句变得很复杂，而且增加，删除，或者更换算法要修改原代码，不易维护，违背开闭原则。策略模式可以很好的解决该问题

+ 优点：
  + 1、多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句
  + 2、策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码
  + 3、策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的
  + 4、策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法
  + 5、策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。

+ 确定：
  + 客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。
  + 策略模式造成很多的策略类，增加维护难度。


# 开闭原则
 + 开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。